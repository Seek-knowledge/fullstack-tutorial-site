(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{216:function(t,e,r){t.exports=r.p+"assets/img/ioc1.0aa54c95.jpg"},217:function(t,e,r){t.exports=r.p+"assets/img/ioc2.fb67ce68.jpg"},218:function(t,e,r){t.exports=r.p+"assets/img/ioc3.85455151.jpg"},219:function(t,e,r){t.exports=r.p+"assets/img/ioc4.6000da2e.jpg"},220:function(t,e,r){t.exports=r.p+"assets/img/ioc5.85f4ff6d.jpg"},221:function(t,e,r){t.exports=r.p+"assets/img/ioc6.d72b59ad.jpg"},222:function(t,e,r){t.exports=r.p+"assets/img/ioc7.e17fb600.jpg"},223:function(t,e,r){t.exports=r.p+"assets/img/ioc8.d23d4e93.jpg"},224:function(t,e,r){t.exports=r.p+"assets/img/ioc9.20c476cd.jpg"},225:function(t,e,r){t.exports=r.p+"assets/img/ioc10.0f8b9f24.jpg"},226:function(t,e,r){t.exports=r.p+"assets/img/ioc11.03a11213.jpg"},227:function(t,e,r){t.exports=r.p+"assets/img/ioc12.bae7982f.jpg"},228:function(t,e,r){t.exports=r.p+"assets/img/ioc13.44de4810.png"},255:function(t,e,r){"use strict";r.r(e);var i=[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[r("a",{attrs:{href:"#%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAioc"}},[t._v("深入浅出IOC")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"}},[t._v("什么是依赖倒置原则")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"}},[t._v("控制反转和依赖注入")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E7%9A%84%E5%A5%BD%E5%A4%84"}},[t._v("控制反转的好处")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#%E6%80%BB%E7%BB%93"}},[t._v("总结")])])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"深入浅出ioc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#深入浅出ioc","aria-hidden":"true"}},[this._v("#")]),this._v(" 深入浅出IOC")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("要了解"),e("strong",[this._v("控制反转( Inversion of Control )")]),this._v(", 我觉得有必要先了解软件设计的一个重要思想："),e("strong",[this._v("依赖倒置原则（Dependency Inversion Principle ）")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"什么是依赖倒置原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是依赖倒置原则","aria-hidden":"true"}},[this._v("#")]),this._v(" 什么是依赖倒置原则")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:r(216),width:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:r(217),width:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"控制反转和依赖注入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#控制反转和依赖注入","aria-hidden":"true"}},[this._v("#")]),this._v(" 控制反转和依赖注入")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("控制反转（Inversion of Control）")]),this._v(" 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的"),e("strong",[this._v("依赖注入（Dependency Injection）")]),this._v("。其实这些概念初次接触都会感到云里雾里的。说穿了，这几种概念的关系大概如下：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:r(218),width:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("为了理解这几个概念，我们还是用上面汽车的例子。只不过这次换成代码。我们先定义四个Class，"),e("strong",[this._v("车，车身，底盘，轮胎")]),this._v("。然后初始化这辆车，最后跑这辆车。代码结构如下：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:r(219),width:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:r(220),width:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:r(221),width:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("由此我们可以看到，仅仅是为了修改轮胎的构造函数，这种设计却需要"),e("strong",[this._v("修改整个上层所有类的构造函数")]),this._v("！在软件工程中，"),e("strong",[this._v("这样的设计几乎是不可维护的")]),this._v("——在实际工程项目中，有的类可能会是几千个类的底层，如果每次修改这个类，我们都要修改所有以它作为依赖的类，那软件的维护成本就太高了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("所以我们需要进行控制反转（IoC），及上层控制下层，而不是下层控制着上层。我们用依赖注入（Dependency Injection）这种方式来实现控制反转。"),e("strong",[this._v("所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制")]),this._v("”。这里我们用"),e("strong",[this._v("构造方法传递的依赖注入方式")]),this._v("重新写车类的定义：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:r(222),width:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:r(223),width:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("看到没？这里 "),e("strong",[this._v("我只需要修改轮胎类就行了，不用修改其他任何上层类。")]),this._v(" 这显然是更容易维护的代码。不仅如此，在实际的工程中，这种设计模式还有利于**不同组的协同合作和单元测试：**比如开发这四个类的分别是四个不同的组，那么只要定义好了接口，四个不同的组可以同时进行开发而不相互受限制；而对于单元测试，如果我们要写Car类的单元测试，就只需要Mock（ 模拟）一下Framework类传入Car就行了，而不用把Framework, Bottom, Tire全部new一遍再来构造Car。")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("p",[t._v("这里我们是采用的"),r("strong",[t._v("构造函数传入")]),t._v("的方式进行的依赖注入。其实还有另外两种方法："),r("strong",[t._v("Setter传递")]),t._v("和"),r("strong",[t._v("接口传递")]),t._v("。这里就不多讲了，核心思路都是一样的，都是为了实现"),r("strong",[t._v("控制反转")]),t._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:r(224),width:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"控制反转的好处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#控制反转的好处","aria-hidden":"true"}},[this._v("#")]),this._v(" 控制反转的好处")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("看到这里你应该能理解什么控制反转和依赖注入了。那什么是 "),e("strong",[this._v("控制反转容器(IoC Container)")]),this._v(" 呢？其实上面的例子中，对车类进行初始化的那段代码发生的地方，就是控制反转容器。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:r(225),width:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("显然你也应该观察到了，因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new。这里IoC容器就解决了这个问题。"),e("strong",[this._v("这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化一辆车都要亲手去写那一大段初始化的代码")]),this._v("。这是引入IoC Container的第一个好处。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:r(226),width:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:r(227),width:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:r(228),width:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[this._v("#")]),this._v(" 总结")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("实际项目中，有的Service Class可能是十年前写的，有几百个类作为它的底层。假设我们新写的一个API需要实例化这个Service，我们总不可能回头去搞清楚这几百个类的构造函数吧？IoC Container的这个特性就很完美的解决了这类问题——"),e("strong",[this._v("因为这个架构要求你在写class的时候需要写相应的Config文件，所以你要初始化很久以前的Service类的时候，前人都已经写好了Config文件，你直接在需要用的地方注入这个Service就可以了")]),this._v("。这大大增加了项目的可维护性且降低了开发难度。")])}],s=r(0),n=Object(s.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),r("p",[t._v("假设我们设计一辆汽车：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。这里就出现了一个“依赖”关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。")]),t._v(" "),t._m(4),r("br"),t._v(" "),r("p",[t._v("这样的设计看起来没问题，但是可维护性却很低。假设设计完工之后，上司却突然说根据市场需求的变动，要我们把车子的轮子设计都改大一码。这下我们就蛋疼了：因为我们是根据轮子的尺寸设计的底盘，轮子的尺寸一改，底盘的设计就得修改；同样因为我们是根据底盘设计的车身，那么车身也得改，同理汽车设计也得改——整个设计几乎都得改！")]),t._v(" "),r("p",[t._v("我们现在换一种思路。我们先设计汽车的大概样子，然后根据汽车的样子来设计车身，根据车身来设计底盘，最后根据底盘来设计轮子。这时候，依赖关系就倒置过来了：轮子依赖底盘， 底盘依赖车身， 车身依赖汽车。")]),t._v(" "),t._m(5),r("br"),t._v(" "),r("p",[t._v("这时候，上司再说要改动轮子的设计，我们就只需要改动轮子的设计，而不需要动底盘，车身，汽车的设计了。")]),t._v(" "),r("p",[t._v("这就是依赖倒置原则——把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况。")]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),r("br"),t._v(" "),t._m(9),t._v(" "),t._m(10),r("br"),t._v(" "),r("p",[t._v("这样，就相当于上面第一个例子，上层建筑依赖下层建筑——每一个类的构造函数都直接调用了底层代码的构造函数。假设我们需要改动一下轮胎（Tire）类，把它的尺寸变成动态的，而不是一直都是30。我们需要这样改：")]),t._v(" "),t._m(11),r("br"),t._v(" "),r("p",[t._v("由于我们修改了轮胎的定义，为了让整个程序正常运行，我们需要做以下改动：")]),t._v(" "),t._m(12),r("br"),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),r("br"),t._v(" "),r("p",[t._v("这里我们再把轮胎尺寸变成动态的，同样为了让整个系统顺利运行，我们需要做如下修改：")]),t._v(" "),t._m(16),r("br"),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),r("br"),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),r("br"),t._v(" "),t._m(23),t._v(" "),r("p",[t._v("IoC Container的第二个好处是：**我们在创建实例的时候不需要了解其中的细节。**在上面的例子中，我们自己手动创建一个车instance时候，是从底层往上层new的：")]),t._v(" "),t._m(24),r("br"),t._v(" "),r("p",[t._v("这个过程中，我们需要了解整个Car/Framework/Bottom/Tire类构造函数是怎么定义的，才能一步一步new/注入。")]),t._v(" "),r("p",[t._v("而IoC Container在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new（有点像深度优先遍历）：")]),t._v(" "),t._m(25),r("br"),t._v(" "),r("p",[t._v("这里IoC Container可以直接隐藏具体的创建实例的细节，在我们来看它就像一个工厂：")]),t._v(" "),t._m(26),r("br"),t._v(" "),r("p",[t._v("我们就像是工厂的客户。我们只需要向工厂请求一个Car实例，然后它就给我们按照Config创建了一个Car实例。我们完全不用管这个Car实例是怎么一步一步被创建出来。")]),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),r("p",[t._v("这里只是很粗略的讲了一下我自己对IoC和DI的理解。主要的目的是在于"),r("strong",[t._v("最大限度避免晦涩难懂的专业词汇，用尽量简洁，通俗，直观的例子")]),t._v("来解释这些概念。如果让大家能有一个类似“哦！原来就是这么个玩意嘛！”的印象，我觉得就OK了。想要深入了解的话，可以上网查阅一些更权威的资料。这里推荐一下 "),r("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Dependency_injection",target:"_blank",rel:"noopener noreferrer"}},[t._v("Dependency injection "),r("OutboundLink")],1),t._v(" 和 "),r("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//martinfowler.com/articles/injection.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Inversion of Control Containers and the Dependency Injection pattern"),r("OutboundLink")],1),t._v(" 这两篇文章，讲的很好很详细。")])])},i,!1,null,null,null);n.options.__file="深入浅出IOC.md";e.default=n.exports}}]);